import { SqliteConnection } from "../../connections/SqliteConnection"
import { DynamicCondition, dynamicPick } from "../../dynamicCondition"
import { extractColumnsFrom, mapForGuidedSplit, mergeType, prefixCapitalized, prefixDotted, prefixMapForGuidedSplitCapitalized, prefixMapForGuidedSplitDotted, prefixMapForSplitCapitalized, prefixMapForSplitDotted } from "../../extras/utils"
import { ConsoleLogQueryRunner } from "../../queryRunners/ConsoleLogQueryRunner"
import { MockQueryRunner } from "../../queryRunners/MockQueryRunner"
import { Table } from "../../Table"
import { CustomBooleanTypeAdapter } from "../../TypeAdapter"
import { View } from "../../View"
import { assertEquals } from "../assertEquals"

class DBConection extends SqliteConnection<'DBConnection'> { 
    // insesitiveCollation = 'acs'

    bitwiseShiftLeft = this.buildFragmentWithArgs(
        this.arg('int', 'required'),
        this.arg('int', 'required')
    ).as((left, right) => {
        // The fragment here is: ${left} << ${right}
        // Could be another fragment like a function call: myFunction(${left}, ${right})
        return this.fragmentWithType('int', 'required').sql`${left} << ${right}`
    })

    valuePlusOneEqualsIfValue = this.buildFragmentWithArgsIfValue(
        this.arg('int', 'required'),
        this.valueArg('int', 'optional')
    ).as((left, right) => {
        // The fragment here is: ${left} + 1 = ${right}
        // Could be another fragment like a function call: myFunction(${left}, ${right})
        return this.fragmentWithType('boolean', 'required').sql`${left} + 1 = ${right}`
    })

    forSystemTimeBetween = this.createTableOrViewCustomization<Date, Date>((table, alias, fromDate, toDate) => {
        const from = this.const(fromDate, 'localDateTime')
        const to = this.const(toDate, 'localDateTime')
        return this.rawFragment`${table} for system_time between ${from} and ${to} ${alias}`
    })
}

const tCompany = new class TCompany extends Table<DBConection, 'TCompany'> {
    id = this.autogeneratedPrimaryKey('id', 'int')
    name = this.column('name', 'string')
    parentId = this.optionalColumn('parent_id', 'int')
    constructor() {
        super('company'); // table name in the database
    }
}()

const tCustomer = new class TCustomer extends Table<DBConection, 'TCustomer'> {
    id = this.autogeneratedPrimaryKey('id', 'int')
    firstName = this.column('first_name', 'string')
    lastName = this.column('last_name', 'string')
    birthday = this.optionalColumn('birthday', 'localDate')
    companyId = this.column('company_id', 'int')
    constructor() {
        super('customer'); // table name in the database
    }
}()

const vCustomerAndCompany = new class VCustomerAndCompany extends View<DBConection, 'VCustomerAndCompany'> {
    companyId = this.column('company_id', 'int')
    companyName = this.column('company_name', 'string')
    customerId = this.column('customer_id', 'int')
    customerFirstName = this.column('customer_first_name', 'string')
    customerLastName = this.column('customer_last_name', 'string')
    customerBirthday = this.optionalColumn('customer_birthday', 'localDate')
    constructor() {
        super('customer_company')
    }
}()
vCustomerAndCompany.as('testView')

const tCustomCompany = new class TCustomCompany extends Table<DBConection, 'TCustomCompany'> {
    id = this.autogeneratedPrimaryKey('id', 'int');
    name = this.column('name', 'string');
    isBig = this.column('is_big', 'boolean', new CustomBooleanTypeAdapter('Y', 'N'));
    constructor() {
        super('custom_company'); // table name in the database
    }
}()

async function main() {
    let result: any
    const expectedResult: any[] = []
    const expectedQuery: string[] = []
    const expectedParams: string[] = []
    const expectedType: string[] = []
    const mockQueryRunner = new MockQueryRunner(
        (type, query, params, index) => {
            assertEquals(query, expectedQuery[index])
            assertEquals(JSON.stringify(params), expectedParams[index])
            assertEquals(type, expectedType[index])
            return expectedResult[index]
        }
    )

    const connection = new DBConection(new ConsoleLogQueryRunner(mockQueryRunner))

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const customerId = 10
    
    const customerWithId = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithId, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || ? || last_name as name, birthday as birthday from customer where first_name like ('%' || ? || '%') escape '\\' order by lower(name), birthday is null, birthday asc`)
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const firstNameContains = 'ohn'
    const lastNameContains = null
    const birthdayIs = null
    const searchOrderBy = 'name insensitive, birthday asc nulls last'
    
    const searchedCustomers = await connection.selectFrom(tCustomer)
        .where(
                    tCustomer.firstName.containsIfValue(firstNameContains)
                .or(tCustomer.lastName.containsIfValue(lastNameContains))
            ).and(
                tCustomer.birthday.equalsIfValue(birthdayIs)
            )
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || ? || last_name as name, birthday as birthday from customer where first_name like ('%' || ? || '%') escape '\\' order by lower(name), birthday is null, birthday asc`)
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    let searchedCustomersWhere = connection.dynamicBooleanExpressionUsing(tCustomer)
    if (firstNameContains) {
        searchedCustomersWhere = searchedCustomersWhere.and(tCustomer.firstName.contains(firstNameContains))
    }
    if (lastNameContains) {
        searchedCustomersWhere = searchedCustomersWhere.or(tCustomer.lastName.contains(lastNameContains))
    }
    if (birthdayIs) {
        searchedCustomersWhere = searchedCustomersWhere.and(tCustomer.birthday.equals(birthdayIs))
    }
    
    const searchedCustomers2 = await connection.selectFrom(tCustomer)
        .where(searchedCustomersWhere)
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers2, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || ? || last_name as name, birthday as birthday from customer where first_name like ('%' || ? || '%') escape '\\' order by lower(name), birthday is null, birthday asc`)
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const hideId = false

    let searchedCustomersWhere3
    if (firstNameContains) {
        searchedCustomersWhere3 = tCustomer.firstName.contains(firstNameContains)
    } else {
        searchedCustomersWhere3 = connection.noValueBoolean()
    }
    if (lastNameContains) {
        searchedCustomersWhere3 = mergeType(searchedCustomersWhere3).or(tCustomer.lastName.contains(lastNameContains))
    }
    if (birthdayIs) {
        searchedCustomersWhere3 = mergeType(searchedCustomersWhere3).and(tCustomer.birthday.equals(birthdayIs))
    }
    searchedCustomersWhere3 = mergeType(searchedCustomersWhere3)
    
    let idColumn
    if (hideId) {
        idColumn = connection.optionalConst(null, 'int')
    } else {
        idColumn = tCustomer.id
    }
    idColumn = mergeType(idColumn)
    
    const searchedCustomers3 = await connection.selectFrom(tCustomer)
        .where(searchedCustomersWhere3)
        .select({
            id: idColumn,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers3, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, comp.name as companyName from customer inner join company as comp on customer.company_id = comp.id where lower(customer.first_name) like lower(? || '%') escape '\\' order by lower(firstName), lower(lastName) asc`)
    expectedParams.push(`["John"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const firstName = 'John'
    const lastName = null
    
    const company = tCompany.as('comp')
    const customersWithCompanyName = await connection.selectFrom(tCustomer)
        .innerJoin(company).on(tCustomer.companyId.equals(company.id))
        .where(tCustomer.firstName.startsWithInsensitive(firstName))
            .and(tCustomer.lastName.startsWithInsensitiveIfValue(lastName))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday,
            companyName: company.name
        })
        .orderBy('firstName', 'insensitive')
        .orderBy('lastName', 'asc insensitive')
        .executeSelectMany()
    
    assertEquals(customersWithCompanyName, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as customerId, first_name as customerFirstName, last_name as customerLastName from customer where company_id in (select id as result from company where name like ('%' || ? || '%') escape '\\') order by customerFirstName asc, customerLastName`)
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const orderBy = 'customerFirstName asc nulls first, customerLastName'
    const customerWithSelectedCompanies = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany)
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(tCompany.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        }).orderByFromString(orderBy)
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompany = await connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        }).groupBy('companyId', 'companyName')
        .executeSelectMany()
    
    assertEquals(customerCountPerCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompany2 = await connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .groupBy(tCompany.id, tCompany.name)
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        })
        .executeSelectMany()
    
    assertEquals(customerCountPerCompany2, result)
    
    /* *** Preparation ************************************************************/

    result = {
        data: [],
        count: 0
    }
    expectedResult.push([])
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName from customer where lower(first_name) like lower(? || '%') escape '\\' or lower(last_name) like lower(? || '%') escape '\\' order by firstName, lastName limit ? offset ?`)
    expectedParams.push(`["Smi","Smi",10,20]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push(0)
    expectedQuery.push(`select count(*) from customer where lower(first_name) like lower(? || '%') escape '\\' or lower(last_name) like lower(? || '%') escape '\\'`)
    expectedParams.push(`["Smi","Smi"]`)
    expectedType.push(`selectOneColumnOneRow`)
    
    /* *** Example ****************************************************************/

    const customerName = 'Smi'
    const customerPageWithName = await connection.selectFrom(tCustomer)
        .where(
            tCustomer.firstName.startsWithInsensitive(customerName)
        ).or(
            tCustomer.lastName.startsWithInsensitive(customerName)
        ).select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .orderBy('firstName')
        .orderBy('lastName')
        .limit(10)
        .offset(20)
        .executeSelectPage()
    
    assertEquals(customerPageWithName, result)
    
    /* *** Preparation ************************************************************/

    result = null
    expectedResult.push(result)
    expectedQuery.push(`select id::varchar as idAsString, first_name || ? || last_name as name from customer where !!id = !!?`)
    expectedParams.push(`[" ",10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const id = 10
    const customersUsingCustomFragment = await connection.selectFrom(tCustomer)
        .where(connection.fragmentWithType('boolean', 'required').sql`!!${tCustomer.id} = !!${connection.const(id, 'int')}`)
        .select({
            idAsString: connection.fragmentWithType('string', 'required').sql`${tCustomer.id}::varchar`,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName)
        })
        .executeSelectNoneOrOne()
    
    assertEquals(customersUsingCustomFragment, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, id << ? as idMultiplyBy2 from company where (id * ?) = (id << ?)`)
    expectedParams.push(`[1,2,1]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const bitwiseMovements = 1
    const multiplier = 2
    const companiesUsingCustomFunctionFragment = await connection.selectFrom(tCompany)
        .where(tCompany.id.multiply(multiplier).equals(connection.bitwiseShiftLeft(tCompany.id, bitwiseMovements)))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            idMultiplyBy2: connection.bitwiseShiftLeft(tCompany.id, bitwiseMovements)
        })
        .executeSelectMany()
    
    assertEquals(companiesUsingCustomFunctionFragment, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name from company where id + 1 = ?`)
    expectedParams.push(`[2]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const noValue = null
    const withValue = 2
    const companiesUsingCustomFunctionFragmentIfValue = await connection.selectFrom(tCompany)
        .where(connection.valuePlusOneEqualsIfValue(tCompany.id, noValue))
            .or(connection.valuePlusOneEqualsIfValue(tCompany.id, withValue))
        .select({
            id: tCompany.id,
            name: tCompany.name,
        })
        .executeSelectMany()
    
    assertEquals(companiesUsingCustomFunctionFragmentIfValue, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id, birthday) values (?, ?, ?, ?)`)
    expectedParams.push(`["John","Smith",1,"2000-02-01"]`)
    expectedType.push(`insertReturningLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const insertCustomer = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).setIfNotSet({
            birthday: new Date('2000-03-01')
        }).returningLastInsertedId()
        .executeInsert()
    
    assertEquals(insertCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = [2, 3]
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values (?, ?, ?), (?, ?, ?) returning id`)
    expectedParams.push(`["John","Smith",1,"Other","Person",1]`)
    expectedType.push(`insertReturningMultipleLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const valuesToInsert = [
        {
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        },
        {
            firstName: 'Other',
            lastName: 'Person',
            companyId: 1
        }
    ]
    
    const insertMultipleCustomers = await connection.insertInto(tCustomer)
        .values(valuesToInsert)
        .returningLastInsertedId()
        .executeInsert();
    
    assertEquals(insertMultipleCustomers, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) select first_name as firstName, last_name as lastName, company_id as companyId from customer where company_id = ?`)
    expectedParams.push(`[1]`)
    expectedType.push(`insert`)
    
    /* *** Example ****************************************************************/

    const insertCustomersFromSelect = await connection.insertInto(tCustomer)
        .from(
            connection.selectFrom(tCustomer)
            .where(
                tCustomer.companyId.equals(1)
            )
            .select({
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                companyId: tCustomer.companyId
            })
        )
        .executeInsert();
    
    assertEquals(insertCustomersFromSelect, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update customer set first_name = ?, last_name = ? where id = ?`)
    expectedParams.push(`["John","Smith",10]`)
    expectedType.push(`update`)
    
    /* *** Example ****************************************************************/

    const updateCustomer = await connection.update(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('2000-03-01')
        }).ignoreIfSet('birthday')
        .where(tCustomer.id.equals(10))
        .executeUpdate()
    
    assertEquals(updateCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`delete from customer where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`delete`)
    
    /* *** Example ****************************************************************/

    const deleteCustomer = await connection.deleteFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .executeDelete()
    
    assertEquals(deleteCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with customerCountPerCompany as (select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name) select companyId as acmeCompanyId, companyName as acmeCompanyName, customerCount as acmeCustomerCount from customerCountPerCompany where lower(companyName) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompanyWith = connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        }).groupBy('companyId', 'companyName')
        .forUseInQueryAs('customerCountPerCompany')
    
    const customerCountPerAcmeCompanies = await connection.selectFrom(customerCountPerCompanyWith)
        .where(customerCountPerCompanyWith.companyName.containsInsensitive('ACME'))
        .select({
            acmeCompanyId: customerCountPerCompanyWith.companyId,
            acmeCompanyName: customerCountPerCompanyWith.companyName,
            acmeCustomerCount: customerCountPerCompanyWith.customerCount
        })
        .executeSelectMany()
    
    assertEquals(customerCountPerAcmeCompanies, result)
    
    /* *** Preparation ************************************************************/
    
    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into custom_company (name, is_big) values (?, case when ? then 'Y' else 'N' end)`)
    expectedParams.push(`["My Big Company",true]`)
    expectedType.push(`insertReturningLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const insertCustomCompany = await connection.insertInto(tCustomCompany).set({
            name: 'My Big Company',
            isBig: true
        }).returningLastInsertedId()
        .executeInsert()
    
    assertEquals(insertCustomCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (is_big = 'Y') as isBig from custom_company where is_big = 'Y'`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const selectAllBigCompanies = await connection.selectFrom(tCustomCompany)
        .where(tCustomCompany.isBig)
        .select({
            id: tCustomCompany.id,
            name: tCustomCompany.name,
            isBig: tCustomCompany.isBig
        }).executeSelectMany()
    
    assertEquals(selectAllBigCompanies, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.name as companyName from customer inner join company on customer.company_id = company.id where (lower(customer.first_name) like lower(? || '%') escape '\\' or (lower(customer.last_name) like lower(? || '%') escape '\\' and customer.last_name like ('%' || ?) escape '\\')) and company.name = ? order by lower(firstName), lower(lastName) asc`)
    expectedParams.push(`["John","Smi","th","ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    type FilterType = DynamicCondition<{
        id: 'int',
        firstName: 'string',
        lastName: 'string',
        birthday: 'localDate',
        companyName: 'string'
    }>
    
    const filter: FilterType = {
        or: [
            { firstName: { startsWithInsensitive: 'John' } },
            { lastName: { startsWithInsensitiveIfValue: 'Smi', endsWith: 'th' } }
        ],
        companyName: {equals: 'ACME'}
    }
    
    const selectFields = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyName: tCompany.name
    }
    
    const dynamicWhere = connection.dynamicConditionFor(selectFields).withValues(filter)
    
    const customersWithDynamicCondition = await connection.selectFrom(tCustomer)
        .innerJoin(tCompany).on(tCustomer.companyId.equals(tCompany.id))
        .where(dynamicWhere)
        .select(selectFields)
        .orderBy('firstName', 'insensitive')
        .orderBy('lastName', 'asc insensitive')
        .executeSelectMany()
    
    assertEquals(customersWithDynamicCondition, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || ? || last_name as name, ? as type from customer union all select id as id, name as name, ? as type from company`)
    expectedParams.push(`[" ","customer","company"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const allDataWithName = await connection.selectFrom(tCustomer)
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            type: connection.const<'customer' | 'company'>('customer', 'enum', 'customerOrCompany')
        }).unionAll(
            connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name,
                type: connection.const<'customer' | 'company'>('company', 'enum', 'customerOrCompany')
            })
        ).executeSelectMany()
    
    assertEquals(allDataWithName, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 10,
        name: 'ACME Inc.',
        customers: [{
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14Z')
        }, {
            id: 13,
            firstName: 'Jorge',
            lastName: 'Justo',
            birthday: new Date('1991/2/16Z')
        }]
    }, {
        id: 11,
        name: 'ACME Corp.',
        customers: [{
            id: 14,
            firstName: 'Maria',
            lastName: 'Rodriguez',
            birthday: new Date('1992/3/18Z')
        }]
    }]
    expectedResult.push([{
        id: 10,
        name: 'ACME Inc.'
    }, {
        id: 11,
        name: 'ACME Corp.'
    }])
    expectedQuery.push(`select id as id, name as name from company where lower(name) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push([{
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14Z'),
        companyId: 10
    }, {
        id: 13,
        firstName: 'Jorge',
        lastName: 'Justo',
        birthday: new Date('1991/2/16Z'),
        companyId: 10
    }, {
        id: 14,
        firstName: 'Maria',
        lastName: 'Rodriguez',
        birthday: new Date('1992/3/18Z'),
        companyId: 11
    }])
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where company_id in (?, ?)`)
    expectedParams.push(`[10,11]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companiesWithCustomers = await connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name
            }).where(
                tCompany.name.containsInsensitive('ACME')
            ).composeDeletingInternalProperty({
                externalProperty: 'id',
                internalProperty: 'companyId',
                propertyName: 'customers'
            }).withMany((ids) => {
                return connection.selectFrom(tCustomer)
                    .select({
                        id: tCustomer.id,
                        firstName: tCustomer.firstName,
                        lastName: tCustomer.lastName,
                        birthday: tCustomer.birthday,
                        companyId: tCustomer.companyId
                    }).where(
                        tCustomer.companyId.in(ids)
                    ).executeSelectMany()
            }).executeSelectMany()
    
    assertEquals(companiesWithCustomers, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        companyId: 10
    })
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    expectedResult.push([{
        id: 10,
        name: 'ACME Inc.'
    }])
    expectedQuery.push(`select id as id, name as name from company where id in (?)`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerWithCompany = await connection.selectFrom(tCustomer)
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                birthday: tCustomer.birthday,
                companyId: tCustomer.companyId
            }).where(
                tCustomer.id .equals(12)
            ).composeDeletingExternalProperty({
                externalProperty: 'companyId',
                internalProperty: 'id',
                propertyName: 'company'
            }).withOne((ids) => {
                return connection.selectFrom(tCompany)
                    .select({
                        id: tCompany.id,
                        name: tCompany.name
                    }).where(
                        tCompany.id.in(ids)
                    ).executeSelectMany()
            }).executeSelectOne()
    
    assertEquals(customerWithCompany, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        companyId: 10,
        companyName: 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.id as companyId, company.name as companyName from customer inner join company on company.id = customer.company_id where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerWithCompanyInOneQuery = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                birthday: tCustomer.birthday,
                companyId: tCompany.id,
                companyName: tCompany.name
            }).where(
                tCustomer.id .equals(12)
            ).split('company', {
                id: 'companyId',
                name: 'companyName'
            }).executeSelectOne()

    assertEquals(customerWithCompanyInOneQuery, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.id as "company.id", company.name as "company.name" from customer inner join company on company.id = customer.company_id where company.name = ? and (lower(customer.first_name) like lower('%' || ? || '%') escape '\\' or lower(customer.last_name) like lower('%' || ? || '%') escape '\\') order by lower("company.name") asc, birthday desc`)
    expectedParams.push(`["ACME","John","Smi"]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    type QueryFilterType = DynamicCondition<{
        id: 'int',
        firstName: 'string',
        lastName: 'string',
        birthday: 'localDate',
        'company.id': 'int',
        'company.name': 'string'
    }>
    
    const queryFilter: QueryFilterType = {
        'company.name': {equals: 'ACME'},
        or: [
            { firstName: { containsInsensitive: 'John' } },
            { lastName: { containsInsensitive: 'Smi' } }
        ]
    }
    
    const queryOrderBy = 'company.name asc insensitive, birthday desc'
    
    const querySelectFields = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        'company.id': tCompany.id,
        'company.name': tCompany.name
    }
    
    const queryDynamicWhere = connection.dynamicConditionFor(querySelectFields).withValues(queryFilter)
    
    const customerWithCompanyObject = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select(querySelectFields)
            .where(queryDynamicWhere)
            .orderByFromString(queryOrderBy)
            .split('company', {
                id: 'company.id',
                name: 'company.name'
            }).executeSelectOne()
    
    assertEquals(customerWithCompanyObject, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = ? union select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.parentId = company.id) select id as id, name as name, parentId as parentId from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveParentCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnion((child) => {
            return connection.selectFrom(tCompany)
            .join(child).on(child.parentId.equals(tCompany.id))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                parentId: tCompany.parentId
            })
        }).executeSelectMany()
    
    assertEquals(recursiveParentCompany, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = ? union select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.parentId = company.id) select id as id, name as name, parentId as parentId from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveOnParentCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnionOn((child) => {
            return child.parentId.equals(tCompany.id)
        }).executeSelectMany()
    
    assertEquals(recursiveOnParentCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = ? union all select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.id = company.parent_id) select id as id, name as name, parentId as parentId from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveChildrenCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnionAll((parent) => {
            return connection.selectFrom(tCompany)
            .join(parent).on(parent.id.equals(tCompany.parentId))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                parentId: tCompany.parentId
            })
        }).executeSelectMany()
    
    assertEquals(recursiveChildrenCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = ? union all select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.id = company.parent_id) select id as id, name as name, parentId as parentId from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveOnChildrenCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnionAllOn((parent) => {
            return parent.id.equals(tCompany.parentId)
        }).executeSelectMany()
    
    assertEquals(recursiveOnChildrenCompany, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name'
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as parentId, parent.name as parentName from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parent = tCompany.forUseInLeftJoinAs('parent')
    
    const leftJoinCompany = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: parent.id,
            parentName: parent.name
        }).guidedSplitOptional('parent', {
            id: 'parentId!',
            name: 'parentName!'
        }).executeSelectMany()
    
    assertEquals(leftJoinCompany, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName from customer`)
    expectedParams.push(`[]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const availableFields = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday
    }
    
    const fieldsToPick = {
        firstName: true,
        lastName: true
    }
    
    // include allways id field as required
    const pickedFields = dynamicPick(availableFields, fieldsToPick, ['id'])
    
    const customerWithIdPeaking = await connection.selectFrom(tCustomer)
        .select(pickedFields)
        .executeSelectOne()
    
    assertEquals(customerWithIdPeaking, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName from customer where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields2 = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyId: tCompany.id,
        companyName: tCompany.name
    }
    
    const fieldsToPick2 = {
        firstName: true,
        lastName: true
    }
    
    // include allways id field as required
    const pickedFields2 = dynamicPick(availableFields2, fieldsToPick2, ['id'])
    
    const customerWithOptionalCompany = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields2)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, company.name as companyName from customer inner join company on company.id = customer.company_id where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields3 = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyId: tCompany.id,
        companyName: tCompany.name
    }
    
    const fieldsToPick3 = {
        firstName: true,
        lastName: true,
        companyName: true
    }
    
    // include allways id field as required
    const pickedFields3 = dynamicPick(availableFields3, fieldsToPick3, ['id'])
    
    const customerWithOptionalCompany3 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields3)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany3, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer for system_time between ? and ?  where id = ?`)
    expectedParams.push(`["2019-00-01 01:00:00","2020-00-01 01:00:00",10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerIn2019 = connection.forSystemTimeBetween(tCustomer, 'customerIn2019', new Date('2019-01-01'), new Date('2020-01-01'))
    
    const customerInSystemTime = await connection.selectFrom(customerIn2019)
        .where(customerIn2019.id.equals(10))
        .select({
            id: customerIn2019.id,
            firstName: customerIn2019.firstName,
            lastName: customerIn2019.lastName,
            birthday: customerIn2019.birthday
        })
        .executeSelectMany()
    
    assertEquals(customerInSystemTime, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update /*+ some hints */ customer set first_name = ?, last_name = ? where id = ? keep plan`)
    expectedParams.push(`["John","Smith",10]`)
    expectedType.push(`update`)
    
    /* *** Example ****************************************************************/

    const customizedUpdate = await connection.update(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith'
        }).where(tCustomer.id.equals(10))
        .customizeQuery({
            afterUpdateKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`keep plan`,
        })
        .executeUpdate()
    
    assertEquals(customizedUpdate, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`delete /*+ some hints */ from customer where id = ? keep plan`)
    expectedParams.push(`[10]`)
    expectedType.push(`delete`)
    
    /* *** Example ****************************************************************/

    const customizedDelete = await connection.deleteFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .customizeQuery({
            afterDeleteKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`keep plan`,
        })
        .executeDelete()
    
    assertEquals(customizedDelete, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert /*+ some hints */ into customer (first_name, last_name, company_id) values (?, ?, ?) log errors reject limit unlimited`)
    expectedParams.push(`["John","Smith",1]`)
    expectedType.push(`insert`)
    
    /* *** Example ****************************************************************/

    const customizedInsert = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).customizeQuery({
            afterInsertKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`log errors reject limit unlimited`
        }).executeInsert()

    assertEquals(customizedInsert, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 9,
        firstName: 'First Name',
        lastName: 'Last Name',
        companyId: 7
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where id = ?`)
    expectedParams.push(`[9]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const selectAll = await connection.selectFrom(tCustomer)
        .select(extractColumnsFrom(tCustomer))
        .where(tCustomer.id.equals(9))
        .executeSelectOne()
    
    assertEquals(selectAll, result)
    
    /* *** Preparation ************************************************************/

    result = {
        customer: {
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14'),
        },
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        'customer.id': 12,
        'customer.firstName': 'John',
        'customer.lastName': 'Smith',
        'customer.birthday': new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as "customer.id", customer.first_name as "customer.firstName", customer.last_name as "customer.lastName", customer.birthday as "customer.birthday", company.id as "company.id", company.name as "company.name" from customer inner join company on company.id = customer.company_id where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerColumns = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday
    }
    
    const companyColumns = {
        id: tCompany.id,
        name: tCompany.name
    }
    
    const customerWithCompanyPrefixed = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                ...prefixDotted(customerColumns, 'customer'),
                ...prefixDotted(companyColumns, 'company')
            }).where(
                tCustomer.id.equals(12)
            )
            .split('customer', prefixMapForSplitDotted(customerColumns, 'customer'))
            .split('company', prefixMapForSplitDotted(companyColumns, 'company'))
            .executeSelectOne()
    
    assertEquals(customerWithCompanyPrefixed, result)
    
    /* *** Preparation ************************************************************/

    result = {
        customer: {
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14'),
        },
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        customerId: 12,
        customerFirstName: 'John',
        customerLastName: 'Smith',
        customerBirthday: new Date('1990/1/14'),
        companyId: 10,
        companyName: 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as customerId, customer.first_name as customerFirstName, customer.last_name as customerLastName, customer.birthday as customerBirthday, company.id as companyId, company.name as companyName from customer inner join company on company.id = customer.company_id where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerWithCompanyPrefixed2 = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                ...prefixCapitalized(customerColumns, 'customer'),
                ...prefixCapitalized(companyColumns, 'company')
            }).where(
                tCustomer.id.equals(12)
            )
            .split('customer', prefixMapForSplitCapitalized(customerColumns, 'customer'))
            .split('company', prefixMapForSplitCapitalized(companyColumns, 'company'))
            .executeSelectOne()
    
    assertEquals(customerWithCompanyPrefixed2, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name',
        parentParentId: null
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as parentId, parent.name as parentName, parent.parent_id as parentParentId from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parentCompany = tCompany.forUseInLeftJoinAs('parent')
    
    const companyFields = {
        id: tCompany.id,
        name: tCompany.name
    }
    
    const parentCompanyFields = {
        id: parentCompany.id,
        name: parentCompany.name,
        parentId: parentCompany.parentId
    }
    
    const companyPrefixed = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            ...companyFields,
            ...prefixCapitalized(parentCompanyFields, 'parent')
        }).guidedSplitOptional('parent', prefixMapForGuidedSplitCapitalized(parentCompanyFields, tCompany, 'parent'))
        .executeSelectMany()
    
    assertEquals(companyPrefixed, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name',
            parentId: 8
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name',
        'parent.parentId': 8
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as "parent.id", parent.name as "parent.name", parent.parent_id as "parent.parentId" from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companyPrefixed2 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            ...companyFields,
            ...prefixDotted(parentCompanyFields, 'parent')
        }).guidedSplitOptional('parent', prefixMapForGuidedSplitDotted(parentCompanyFields, tCompany, 'parent'))
        .executeSelectMany()
    
    assertEquals(companyPrefixed2, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            parentId: 18,
            parentName: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name'
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as parentId, parent.name as parentName, parent.parent_id as parentParentId from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parentFields = {
        parentId: parentCompany.id,
        parentName: parentCompany.name,
        parentParentId: parentCompany.parentId
    }
    
    const companyPrefixed3 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            ...parentFields
        }).guidedSplitOptional('parent', mapForGuidedSplit(parentFields, {
            parentId: tCompany.id,
            parentName: tCompany.name,
            parentParentId: tCompany.parentId
        }))
        .executeSelectMany()
    
    assertEquals(companyPrefixed3, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }, {
        id: 20,
        name: 'name3',
        parent: {
            id: 19,
            name: 'name2',
            parent: {
                id: 18,
                name: 'name',
                parentId: 17
            }
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name'
    }, {
        id: 20,
        name: 'name3',
        parentId: 19,
        parentName: 'name2',
        parentParentId: 18,
        parentParentName: 'name',
        parentParentParentId: 17
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as parentId, parent.name as parentName, parentParent.id as parentParentId, parentParent.name as parentParentName, parentParent.parent_id as parentParentParentId from company left join company as parent on company.parent_id = parent.id left join company as parentParent on parent.parent_id = parentParent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parentParent = tCompany.forUseInLeftJoinAs('parentParent')
    
    const companyMultiSplit = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .leftJoin(parentParent).on(parent.parentId.equals(parentParent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: parent.id,
            parentName: parent.name,
            parentParentId: parentParent.id,
            parentParentName: parentParent.name,
            parentParentParentId: parentParent.parentId,
        }).guidedSplitOptional('parentParent', {
            id: 'parentParentId!',
            name: 'parentParentName!',
            parentId: 'parentParentParentId'
        }).guidedSplitOptional('parent', {
            id: 'parentId!',
            name: 'parentName!',
            parent: 'parentParent'
        })
        .executeSelectMany()

    assertEquals(companyMultiSplit, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || ? || last_name as name from customer where company_id = (select id as result from company where name = ?)`)
    expectedParams.push(`[" ","ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const acmeId = connection.selectFrom(tCompany)
        .where(tCompany.name.equals('ACME'))
        .selectOneColumn(tCompany.id)
        .forUseAsInlineQueryValue()

    const acmeCustomers = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(acmeId))
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName)
        })
        .executeSelectMany()

    assertEquals(acmeCustomers, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update customer set last_name = customer.last_name || ? || company.name from company where customer.company_id = company.id and lower(company.name) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`[" - ","ACME"]`)
    expectedType.push(`update`)

    /* *** Example ****************************************************************/

    const addACMECompanyNameToLastName = await connection.update(tCustomer)
        .from(tCompany)
        .set({
            lastName: tCustomer.lastName.concat(' - ').concat(tCompany.name)
        })
        .where(tCustomer.companyId.equals(tCompany.id))
        .and(tCompany.name.containsInsensitive('ACME'))
        .executeUpdate()

    assertEquals(addACMECompanyNameToLastName, result)
}

main().then(() => {
    console.log('All ok')
    process.exit(0)
}).catch((e) => {
    console.error(e)
    process.exit(1)
})