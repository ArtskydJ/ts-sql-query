import { ITableOrView, __getTableOrViewPrivate, __registerTableOrView } from "../utils/ITableOrView"
import type { Column, ColumnWithDefaultValue, ComputedColumn, OptionalColumn, PrimaryKeyAutogeneratedColumn, PrimaryKeyColumn, __ColumnPrivate } from "../utils/Column"
import type { TypeAdapter } from "../TypeAdapter"
import type { SqlBuilder, ToSql } from "../sqlBuilders/SqlBuilder"
import { AnyValueSource, __getValueSourcePrivate } from "../expressions/values"
import { ValueSourceImpl } from "./ValueSourceImpl"
import { CustomBooleanTypeAdapter } from "../TypeAdapter"
import { ProxyTypeAdapter } from "./ProxyTypeAdapter"
import { type } from "../utils/symbols"

export class ColumnImpl extends ValueSourceImpl implements Column, __ColumnPrivate, ToSql {
    [type]: 'column'
    __isColumn: true = true
    __name: string
    __tableOrView: ITableOrView<any>
    __hasDefault: boolean = false
    __isPrimaryKey: boolean = false
    __isAutogeneratedPrimaryKey: boolean = false
    __isComputed = false
    __sequenceName?: string

    constructor(table: ITableOrView<any>, name: string, valueType: string, typeAdapter: TypeAdapter | undefined) {
        super(valueType, 'required', typeAdapter)
        this.__name = name
        this.__tableOrView = table
    }

    __toSql(sqlBuilder: SqlBuilder, params: any[]): string {
        return sqlBuilder._appendColumnName(this.__asColumn(), params)
    }

    __toSqlForCondition(sqlBuilder: SqlBuilder, params: any[]): string {
        return sqlBuilder._appendColumnNameForCondition(this.__asColumn(), params)
    }

    __asColumn(): this & Column {
        return (this as this & Column)
    }

    __asOptionalColumn(): this & OptionalColumn {
        this.__optionalType = 'optional'
        return (this as this & OptionalColumn)
    }

    __asColumnWithDefaultValue(): this & ColumnWithDefaultValue {
        this.__hasDefault = true
        return (this as this & ColumnWithDefaultValue)
    }

    __asOptionalColumnWithDefaultValue(): this & OptionalColumn & ColumnWithDefaultValue {
        this.__optionalType = 'optional'
        this.__hasDefault = true
        return (this as this & OptionalColumn & ColumnWithDefaultValue)
    }

    __asAutogeneratedPrimaryKey(): this & ColumnWithDefaultValue & PrimaryKeyColumn & PrimaryKeyAutogeneratedColumn {
        this.__hasDefault = true
        this.__isPrimaryKey = true
        this.__isAutogeneratedPrimaryKey = true
        return (this as this & ColumnWithDefaultValue & PrimaryKeyColumn & PrimaryKeyAutogeneratedColumn)
    }

    __asAutogeneratedPrimaryKeyBySequence(sequenceName: string): this & ColumnWithDefaultValue & PrimaryKeyColumn & PrimaryKeyAutogeneratedColumn {
        this.__hasDefault = true
        this.__isPrimaryKey = true
        this.__isAutogeneratedPrimaryKey = true
        this.__sequenceName = sequenceName
        return (this as this & ColumnWithDefaultValue & PrimaryKeyColumn & PrimaryKeyAutogeneratedColumn)
    }

    __asPrimaryKey(): this & PrimaryKeyColumn {
        this.__isPrimaryKey = true
        return (this as this & PrimaryKeyColumn)
    }

    __asComputedColumn(): this & ComputedColumn {
        this.__isComputed = true
        return (this as this & ComputedColumn)
    }

    __asOptionalComputedColumn(): this & OptionalColumn & ComputedColumn {
        this.__isComputed = true
        this.__optionalType = 'optional'
        return (this as this & OptionalColumn & ComputedColumn)
    }

    __registerTableOrView(requiredTablesOrViews: Set<ITableOrView<any>>): void {
        __getTableOrViewPrivate(this.__tableOrView).__registerTableOrView(requiredTablesOrViews)
    }

    __registerRequiredColumn(requiredColumns: Set<Column>, onlyForTablesOrViews: Set<ITableOrView<any>>): void {
        if (onlyForTablesOrViews.has(this.__tableOrView)) {
            requiredColumns.add(this)
        }
    }

    __getOldValues(): ITableOrView<any> | undefined {
        return __getTableOrViewPrivate(this.__tableOrView).__getOldValues()
    }
}

export function createColumnsFrom(columns: { [property: string]: AnyValueSource }, target: { [property: string]: AnyValueSource }, table: ITableOrView<any>, ) {
    for (const property in columns) {
        const column = columns[property]!
        const columnPrivate = __getValueSourcePrivate(column)
        let valueType = columnPrivate.__valueType
        let typeAdapter = columnPrivate.__typeAdapter
        if (typeAdapter instanceof CustomBooleanTypeAdapter) {
            // Avoid treat the column as a custom boolean
            typeAdapter = new ProxyTypeAdapter(typeAdapter)
        }
        const withColumn = new ColumnImpl(table, property, valueType, typeAdapter)
        withColumn.__optionalType = columnPrivate.__optionalType
        target[property] = withColumn
    }
}